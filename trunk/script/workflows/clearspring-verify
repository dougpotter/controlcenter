#!/usr/bin/env ruby

require 'optparse'

options = {}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: script/workflows/clearspring-verify [options]"
  
  opts.separator ''
  opts.separator 'Data source options:'
  
  opts.on('-C', '--channel CHANNEL', 'Verify files from specified CHANNEL only (search-hashed-int/search-hashed-us/share-int/share-us/view-int/view-us, default is to verify all channels)') do |source|
    options[:source] = source
  end
  opts.on('-D', '--date DATE', 'Verify files with specified DATE (by default today)') do |date|
    options[:date] = date
  end
  opts.on('-H', '--hour HOUR', 'Verify files with specified HOUR (by default all hours; 24-hour format: 00-23; multiple hours can be specified separated by commas)') do |hours|
    options[:hours] = hours
  end
  
  opts.separator ''
  opts.separator 'Configuration options:'
  
  opts.on('-e', '--environment RAILS_ENV', 'Specify rails environment (development/production/test') do |env|
    ENV['RAILS_ENV'] = env
  end
  opts.on('-c', '--config-file PATH', 'Specify configuration file path (by default, config/workflows/clearspring.yml is used)') do |path|
    options[:config_path] = path
  end
  opts.on('--http-client CLIENT', 'Use specified http client CLIENT (valid values: curb (default), httpclient, net_http, right_aws, spawn_{curl|wget}[_netrc])') do |client|
    options[:http_client] = client
  end
  opts.on('--s3-client CLIENT', 'Use specified s3 client CLIENT (valid values: right_aws (default), spawn_curl') do |client|
    options[:s3_client] = client
  end
  opts.on('--[no-]system-timer', 'Force the use of SystemTimer instead of Timeout') do |value|
    options[:system_timer] = value
  end
  
  opts.separator ''
  opts.separator 'Action options: (by default, check everything except for --check-content)'
  
  opts.on('--check-correspondence', 'Check whether each file in data source has one or more corresponding files in our storage') do
    options[:check_listing] = true
  end
  opts.on('--check-their-existence', 'Checks whether data source appears to have the expected assortment of files') do
    options[:check_their_existence] = true
  end
  opts.on('--check-our-existence', 'Checks whether our storage appears to have the expected assortment of files') do
    options[:check_our_existence] = true
  end
  opts.on('--check-existence', 'Shortcut for --check-their-existence and --check-our-existence together') do
    options[:check_their_existence] = true
    options[:check_our_existence] = true
  end
  opts.on('--check-consistency', 'Smarter union of --check-correspondence and --check-existence: checks whether expected files exist and whether we retrieved all of them') do
    options[:check_consistency] = true
  end
  opts.on('--check-sizes', 'Use with --check-correspondence or --check-consistency; in addition to matching files require that data source and our storage file sizes are similar (allow differences due to different compression levels)') do
    options[:check_sizes] = true
  end
  opts.on('--check-sizes-strictly', 'Like --check-sizes, but tolerate a much smaller difference in sizes assuming data source files were split or recompressed with the same compression level') do
    options[:check_sizes] = true
    options[:check_sizes_strictly] = true
  end
  opts.on('--check-sizes-exactly', 'Like --check-sizes, but require data source and the sum of our storage sizes to be exactly the same (assuming source files were split)') do
    options[:check_sizes] = true
    options[:check_sizes_exactly] = true
  end
  opts.on('--check-content', "In addition to matching files, require that data source and our storage files' content is identical. Warning: performs extreme amount of network I/O since it has to download both data source and our storage copies of all affected files!") do
    options[:check_content] = true
    raise NotImplementedError, "Content check is not yet implemented"
  end
  
  opts.separator ''
  opts.separator 'Debugging options:'
  
  opts.on('-d', '--[no-]debug', 'Enable debugging output') do |value|
    options[:debug] = value
  end
  opts.on('--debug-output PATH', 'Store debug output into a file instead of printing it to standard output') do |path|
    options[:debug_output_path] = path
  end
  
  opts.separator ''
  opts.separator 'Informational options:'
  
  opts.on('-h', '--help', 'Display this help text') do
    puts opts
    exit
  end
end.parse!

if date = options[:date]
  unless date =~ /\A\d{8}\Z/
    raise OptionParser::ParseError, "Invalid date value: #{date}"
  end
else
  date = Time.now.strftime('%Y%m%d')
end

unless options[:check_listing] || options[:check_consistency] ||
  options[:check_our_existence] || options[:check_their_existence]
then
  options[:check_listing] = options[:check_consistency] =
    options[:check_our_existence] = options[:check_their_existence] = true
end

require File.join(File.dirname(__FILE__), '../../config/boot')
require File.join(File.dirname(__FILE__), '../../config/environment')

data_provider = DataProvider.find_by_name('Clearspring')
unless data_provider
  raise "Clearspring data provider not found, is databases seeded?"
end
selected_channels = Workflow.parse_source_specification(data_provider, options[:source])

if options[:hours]
  begin
    options[:hours] = Workflow.parse_hours_specification(options[:hours])
  rescue ArgumentError => e
    raise OptionParser::ParseError, e.message
  end
end

def debug
  require 'ruby-debug'
  debugger
end

$settings = ClearspringExtractWorkflow::Configuration.new(options)
$settings.update(options)

def settings; $settings end

class ClearspringVerifyWorkflowRunner < WorkflowRunner
  def perform(ext_params)
    versions = ext_params[:selected_channels].map do |channel|
      {:channel => channel}
    end
    if ext_params[:hours]
      versions.map! do |version|
        ext_params[:hours].map do |hour|
          version.merge(:hour => hour)
        end
      end.flatten!
    end
    workflows = versions.map do |version_params|
      params = settings.merge(ext_params).to_hash
      %w(check_sizes check_sizes_strictly check_sizes_exactly check_content).each do |key|
        key = key.to_sym
        params[key] = ext_params[key]
      end
      params.update(version_params)
      params[:update_process_status] = false
      params[:logger] = ext_params[:logger]
      ClearspringVerifyWorkflow.new(params)
    end
    
    workflows.each do |workflow|
      if ext_params[:check_listing]
        workflow.check_listing
      elsif ext_params[:check_consistency]
        workflow.check_consistency
      else
        if ext_params[:check_our_existence]
          workflow.check_our_existence
        end
        if ext_params[:check_their_existence]
          workflow.check_their_existence
        end
      end
    end
  end
  
  def handle_exception(exc)
    case exc
    when HttpClient::HttpError
      report_error("Transfer error: #{exc.message} @ #{exc.url}")
      9
    when HttpClient::BaseError
      forward_unhandled_exception(exc, :message => "Unhandled transfer error: #{exc.message} @ #{exc.url}")
      10
    else
      super
    end
  end
end

if options[:system_timer]
  require 'force_system_timer'
end

params = {
  :selected_channels => selected_channels,
  :date => date,
}

%w(
  check_listing check_consistency check_our_existence check_their_existence
  check_sizes check_sizes_strictly check_sizes_exactly check_content
  hours debug debug_output_path http_client
).each do |key|
  key = key.to_sym
  params[key] = options[key]
end

runner = ClearspringVerifyWorkflowRunner.new

begin
  status = runner.run(settings.merge(params).to_hash)
rescue Exception => e
  status = ConsoleUi.handle_unhandled_exception(e)
end
exit(status)
