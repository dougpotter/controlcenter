#!/usr/bin/env ruby

require 'optparse'

options = {}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: script/workflows/clearspring-collect [options]"
  
  opts.separator ''
  opts.separator 'Data source options:'
  
  opts.on('-C', '--channel CHANNEL', 'Extract from specified CHANNEL only (search-hashed-int/search-hashed-us/share-int/share-us/view-int/view-us, default is to extract all channels)') do |source|
    options[:source] = source
  end
  opts.on('-D', '--date DATE', 'Extract for specified DATE (by default today)') do |date|
    options[:date] = date
  end
  opts.on('-H', '--hour HOUR', 'Extract for specified HOUR (by default all hours; 24-hour format: 00-23)') do |hour|
    unless hour =~ /^\d\d?/
      raise OptionParser::ParseError, "Invalid hour value: #{hour}"
    end
    hour = hour.to_i
    if hour < 0 || hour > 23
      raise OptionParser::ParseError, "Hour value out of range: #{hour}"
    end
    options[:hour] = hour
  end
  
  opts.separator ''
  opts.separator 'Configuration options:'
  
  opts.on('-c', '--config-file PATH', 'Specify configuration file path (by default, config/workflows/clearspring.yml is used)') do |path|
    options[:config_path] = path
  end
  
  opts.separator ''
  opts.separator 'Behavior modifying options:'
  
  opts.on('-l', '--lock', 'Use locking and quit without doing anything if resources are busy') do
    options[:lock] = true
  end
  opts.on('-o', '--once', 'Extract each file only if it had not been previously extracted (requires and implies --lock)') do
    options[:once] = options[:lock] = true
  end
  
  opts.separator ''
  opts.separator 'Action options: (by default, discover and extract discovered files)'
  
  opts.on('-i', '--discover', 'Discover files only') do
    options[:discover] = true
  end
  opts.on('-e', '--extract URL', 'Extract file in URL') do |url|
    options[:extract] = url
  end
  
  opts.separator ''
  opts.separator 'Debugging options:'
  
  opts.on('-p', '--profile', 'Profile script') do
    options[:profile] = true
  end
  opts.on('-d', '--debug', 'Enable debugging output') do
    options[:debug] = true
  end
  
  opts.separator ''
  opts.separator 'Informational options:'
  
  opts.on('-h', '--help', 'Display this help text') do
    puts opts
    exit
  end
end.parse!

if options[:discover] && options[:extract]
  raise OptionParser::ParseError, "--discover and --extract cannot be specified simultaneously"
end

all_sources = %w(view-us view-int search-hashed-us search-hashed-int share-us share-int)
if source = options[:source]
  if all_sources.include?(source)
    selected_sources = [source]
  else
    raise OptionParser::ParseError, "Invalid source value: #{source}"
  end
else
  selected_sources = all_sources
end

if date = options[:date]
  unless date =~ /\A\d{8}\Z/
    raise OptionParser::ParseError, "Invalid date value: #{date}"
  end
else
  date = Time.now.strftime('%Y%m%d')
end

require File.join(File.dirname(__FILE__), '../../config/boot')
require File.join(File.dirname(__FILE__), '../../config/environment')

# Uncomment to observe how much i/o is performed
#require 'file_io_debugging'
#FileIoDebugging.activate!

# Important: development version of ruote is required (as of Jun 10, 2010)
# since it contains bugfixes and features we rely on.

require 'yaml'
require 'ostruct'
if options[:profile]
  require 'ruby-prof'
end

def debug
  require 'ruby-debug'
  debugger
end

$config = WorkflowParameters.load(options[:config_path] || WorkflowParameters.absolutize('workflows/clearspring'))

def config
  $config
end

module StrictHashMixin
  class KeyError < StandardError; end
  
  def [](key)
    if has_key?(key)
      super
    else
      raise KeyError, "Key does not exist in hash: #{key}"
    end
  end
end

class StrictHash < Hash
  include StrictHashMixin
end

class StrictHashWithIndifferentAccess < HashWithIndifferentAccess
  include StrictHashMixin
end

$settings = {
  :data_source_path => config.clearspring_root_url,
  :download_root_dir => config.download_root_dir,
  :gzip_root_dir => config.temp_root_dir,
  :http_username => config.clearspring_http_username,
  :http_password => config.clearspring_http_password,
  :net_io_timeout => config.clearspring_net_io_timeout,
  :s3_bucket => config.s3_bucket,
  :clearspring_pid => config.clearspring_pid,
}

def settings; $settings end

def run(ext_params)
  workflows = ext_params[:selected_sources].map do |data_source|
    params = settings.merge({
      :date => ext_params[:date],
      :hour => ext_params[:hour],
      :data_source => data_source,
      :debug => ext_params[:debug],
      :lock => ext_params[:lock],
      :once => ext_params[:once],
    })
    ClearspringExtractWorkflow.new(StrictHashWithIndifferentAccess.new(params))
  end
  
  if ext_params[:extract] && workflows.length > 1
    workflow = workflows.detect do |workflow|
      workflow.should_download_url?(ext_params[:extract])
    end
    if workflow
      workflows = [workflow]
    else
      raise Workflow::FileSpecMismatch, "File url does not match any channel/input parameters"
    end
  end
  
  workflows.each do |workflow|
    if ext_params[:discover]
      files = workflow.discover
      files.each do |file|
        puts file
      end
    elsif ext_params[:extract]
      workflow.extract(ext_params[:extract])
    else
      workflow.run
    end
  end
  0
rescue Workflow::FileAlreadyExtracted
  $stderr.puts("Error: file is already extracted")
  5
rescue Workflow::FileExtractionInProgress
  $stderr.puts("Error: file extraction is in progress")
  6
rescue Workflow::FileSpecMismatch
  $stderr.puts("Error: file does not match specification given")
  7
rescue Workflow::FileNotReady
  $stderr.puts("Error: file is not ready to be extracted")
  8
end

def start_profiling
  RubyProf.measure_mode  = RubyProf::PROCESS_TIME 
  RubyProf.start
end

def stop_profiling
  result = RubyProf.stop
  puts 'Saving graph html view'
  printer = RubyProf::GraphHtmlPrinter.new(result)
  printer.print(File.open('profile-output.html', 'w'), :min_percent => 1)
end

params = {
  :selected_sources => selected_sources,
  :date => date,
  :hour => options[:hour],
  :debug => options[:debug],
  :discover => options[:discover],
  :extract => options[:extract],
  :lock => options[:lock],
  :once => options[:once],
}

if options[:profile]
  start_profiling
  
  begin
    status = run(params)
  ensure
    begin
      stop_profiling
    rescue Exception => e
      puts e
      status = 1
    end
  end
else
  status = run(params)
end

exit(status)
