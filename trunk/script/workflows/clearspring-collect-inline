#!/usr/bin/env ruby

require 'optparse'

options = {}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: script/workflows/clearspring-collect [options]"
  
  opts.on('-s', '--source SOURCE', 'Extract from specified SOURCE only (search-hashed-int/search-hashed-us/share-int/share-us/view-int/view-us, default is to extract all sources)') do |source|
    options[:source] = source
  end
  opts.on('-d', '--date DATE', 'Extract for specified DATE (by default today)') do |date|
    options[:date] = date
  end
  opts.on('-p', '--profile', 'Profile script') do
    options[:profile] = true
  end
  opts.on('-D', '--debug', 'Enable debugging output') do
    options[:debug] = true
  end
end.parse!

all_sources = %w(view-us view-int search-hashed-us search-hashed-int share-us share-int)
if source = options[:source]
  if all_sources.include?(source)
    selected_sources = [source]
  else
    raise OptionParser::ParseError, "Invalid source value: #{source}"
  end
else
  selected_sources = all_sources
end

if date = options[:date]
  unless date =~ /\A\d{8}\Z/
    raise OptionParser::ParseError, "Invalid date value: #{date}"
  end
else
  date = Time.now.strftime('%Y%m%d')
end

require File.join(File.dirname(__FILE__), '../../config/boot')
require File.join(File.dirname(__FILE__), '../../config/environment')

# Uncomment to observe how much i/o is performed
#require 'file_io_debugging'
#FileIoDebugging.activate!

# Important: development version of ruote is required (as of Jun 10, 2010)
# since it contains bugfixes and features we rely on.

require 'yaml'
require 'ostruct'
require 'fileutils'
if options[:profile]
  require 'ruby-prof'
end

def debug
  require 'ruby-debug'
  debugger
end

$config = WorkflowParameters.load('workflows/clearspring')

def config
  $config
end

module StrictHashMixin
  class KeyError < StandardError; end
  
  def [](key)
    if has_key?(key)
      super
    else
      raise KeyError, "Key does not exist in hash: #{key}"
    end
  end
end

class StrictHash < Hash
  include StrictHashMixin
end

class StrictHashWithIndifferentAccess < HashWithIndifferentAccess
  include StrictHashMixin
end

class ClearspringManager
end

class ClearspringWorkflow < ClearspringManager
  attr_reader :params
  
  def initialize(params)
    @params = StrictHashWithIndifferentAccess.new(params)
    @http_client = HttpClient.new(:debug => @params[:debug])
    @parser = WebParser.new
    @gzip_transformer = GzipSplitter.new(:debug => @params[:debug])
    @s3_client = S3Client.new(:debug => @params[:debug])
  end
  
  def run
    files = list_files
    files.each do |file|
      local_path = download(file)
      split_paths = split(local_path)
      split_paths.each do |path|
        upload(path)
      end
    end
  end
  
  private
  
  def list_files
    url = build_data_source_url
    page_text = @http_client.fetch(url + '/')
    files = @parser.parse_any_httpd_file_list(page_text)
    absolute_file_urls = files.map { |file| build_absolute_url(url, file) }
    absolute_file_urls.reject! { |url| !should_download_url?(url) }
    absolute_file_urls
  end
  
  def download(url)
    remote_relative_path = build_relative_path(url)
    local_path = build_local_path(remote_relative_path)
    FileUtils.mkdir_p(File.dirname(local_path))
    @http_client.download(url, local_path)
    local_path
  end
  
  def split(input_path)
    local_relative_path = figure_relative_path(params[:download_root_dir], input_path)
    local_relative_path =~ /^(.*?)(\.log\.gz)?$/
    name, ext = $1, $2
    filename_format = "#{name.sub('%', '%%')}.%03d#{ext}"
    
    local_path = File.join(params[:gzip_root_dir], filename_format)
    FileUtils.mkdir_p(File.dirname(local_path))
    
    dest_files = @gzip_transformer.transform(
      input_path,
      params[:gzip_root_dir],
      filename_format
    )
  end
  
  def upload(local_path)
    @s3_client.put_file(s3_bucket, build_s3_path(local_path), local_path)
  end
  
  # -----
  
  def build_data_source_url
    "#{params[:data_source_path]}/#{params[:data_source]}"
  end
  
  def build_absolute_url(remote_url, file)
    File.join(remote_url, file)
  end
  
  def should_download_url?(url)
    prefix = "#{params[:data_source]}.#{params[:date]}"
    File.basename(url)[0...prefix.length] == prefix
  end
  
  def build_relative_path(remote_url)
    figure_relative_path(params[:data_source_path], remote_url)
  end
  
  def build_local_path(remote_relative_path)
    File.join(params[:download_root_dir], remote_relative_path)
  end
  
  def s3_bucket
    params[:s3_bucket]
  end
  
  def build_s3_path(local_path)
    filename = File.basename(local_path)
    path = "#{params[:clearspring_pid]}/v2/raw-#{params[:data_source]}/#{params[:date]}/#{filename}"
  end
  
  # -----
  
  def figure_relative_path(root, absolute_path)
    root_len, abs_len = root.length, absolute_path.length
    if abs_len < root_len || absolute_path[0...root_len] != root
      raise ArgumentError, "Absolute path #{absolute_path} is not under #{root}"
    end
    relative_path = absolute_path[root_len...abs_len]
    if relative_path[0] == '/'
      relative_path = relative_path[1...relative_path.length]
    end
    relative_path
  end
end

$settings = {
  :data_source_path => config.clearspring_root_url,
  :download_root_dir => config.download_root_dir,
  :gzip_root_dir => config.temp_root_dir,
  :http_username => config.clearspring_http_username,
  :http_password => config.clearspring_http_password,
  :s3_bucket => config.s3_bucket,
  :clearspring_pid => config.clearspring_pid,
}

def settings; $settings end

def run(ext_params)
  jobs = []
  ext_params[:selected_sources].each do |data_source|
    params = settings.merge({
      :date => ext_params[:date],
      :data_source => data_source,
      :debug => ext_params[:debug],
    })
    ClearspringWorkflow.new(params).run
  end
end

def start_profiling
  RubyProf.measure_mode  = RubyProf::PROCESS_TIME 
  RubyProf.start
end

def stop_profiling
  result = RubyProf.stop
  puts 'Saving graph html view'
  printer = RubyProf::GraphHtmlPrinter.new(result)
  printer.print(File.open('profile-output.html', 'w'), :min_percent => 1)
end

params = {:selected_sources => selected_sources, :date => date, :debug => options[:debug]}

if options[:profile]
  start_profiling
  
  begin
    ok = run(params)
  ensure
    begin
      stop_profiling
    rescue Exception => e
      puts e
      ok = false
    end
  end
else
  ok = run(params)
end

unless ok
  exit 1
end
